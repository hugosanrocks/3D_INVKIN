!------------------------------------------------------------------------------------
subroutine Time_evol_elastic()

  use global_parameters_mod
  implicit none
  integer ie

  !DEBUG : call build_init_condition_el

  ! temporary arrays for optimization purpose
  call allocate_working_arrays_op(ndof_local, ndof_local_face)
  do ie=1,nE
     call compute_pointers_op(ie, ndof_local_face)
  end do
  call deallocate_temprary_arrays
  ntime=int(time_simu/delta_t)

  !! block matrix approach--------------------------
!!$  call allocate_block_matrix_arrays
!!$
!!$  do ie=1,nE
!!$     if (mod(ie, 100) ==0) write(*,*) 'Block matrix : ', ie,' / ',  nE
!!$     Dr_x(:,:)=Drx(:,:,ie)
!!$     Dr_y(:,:)=Dry(:,:,ie)
!!$     Dr_z(:,:)=Drz(:,:,ie)
!!$    
!!$     call define_block_matrices(ie, ndof_local, ndof_local_face)
!!$    
!!$     Mfl_global(:,:,:,ie) = Mfl(:,:,:)
!!$     Mds_global(:,:,ie) = Mds(:,:) 
!!$  end do
!!$  call Initial_condition_block_matrix
!!$  call Iterate_time_block_matrix(Mfl_global, Mds_global, Mfl, Mds, vec_rhs, vec_res, vec_fel, ndof_local, ndof_local_face,nE, rk4a, rk4b, rk4c,  ve1, ve2, ve3, ve4, ve5, ve6, delta_t, Am_stf, Fm_stf, ntime, EtoE)
!!$
!!$  return
  !!!------------------------------------------------------

  
  current_time = 0._fp

  write(*,*)
  write(*,*) '        Begin Time Loop (Elastic) ' 
  write(*,*)
  write(*,*) '  Number steps :', ntime
  write(*,*) '  Time step    :', delta_t
  write(*,*)  

  do it= 1, ntime

     !!
     current_time = current_time + delta_t

     !! outputs info
     if (mod(it,100) == 0 ) then
        write(*,'(10x,i5,1x,a1,1x,i5,1x,a1,f5.2,a2)') it ,'/', ntime,'[',(real(it)/real(ntime))*100.,'%]' 
        call take_pressure_x_snapshot_el
        call take_pressure_y_snapshot_el
     end if
       
     !call write_sismogram_el(ndof_local)
     call write_stf(Am_stf, Fm_stf, current_time)

     !! elastic kernel
     call LSERK_elastic(ndof_local)
     !call LSERK_elastic_op(ndof_local)
  end do

end subroutine Time_evol_elastic

!-----------------------------------

subroutine  LSERK_elastic(np)

  !!
  !! ORDER 4 LOW STORAGE RUNGE KUTTA TIME SCHEME
  !!

  use global_parameters_mod
  implicit none
  integer irk, np
  real(kind=fp) current_time_rk

  do irk=1, 5

     !! initialisation of rhs vector
     stress_rhs(:,:,:)=0._fp
     veloc_rhs(:,:,:)=0._fp

     !! time sub-stepping 
     current_time_rk = current_time + rk4c(irk)*delta_t

     !! compute right hand side
     !call elastic_rhs
     call elastic_rhs_op(veloc, stress, veloc_rhs, stress_rhs,  indx_flux_face, indx_free_face, indx_abs_face, &
     &                   indx_flux_face_adj, indx_free_face_adj, indx_abs_face_adj, dof_dof_array, LIFT, &
     &                   Drx, Dry, Drz, Dr_x, Dr_y, Dr_z, nE, ndof, ndof_local, ndof_local_face,&
     &                   vector1,vector2,vector3,vector4,vector5,vector6,vector7,vector8,vector9, &
     &                   vp, vs, rho, stress_jump_el, velocity_jump_el, Jface, nx, ny, nz, &
     &                   normal, Jacobian_2D, weight_vol, Etodof_adj, ref_dof(k)%Ftodof, EtoE)

     !! add source 
     !call add_stress_ricker_source(Am_stf, Fm_stf, current_time_rk, np)
     call add_vertical_ricker_source(Am_stf, Fm_stf, current_time_rk, np)
     !! update stress field 
     stress_res(:,:,:) = rk4a(irk) * stress_res(:,:,:) + delta_t*stress_rhs(:,:,:)
     stress(:,:,:) =  stress(:,:,:) +  rk4b(irk) *stress_res(:,:,:)
     
     !! update veloc field
     veloc_res(:,:,:) = rk4a(irk) * veloc_res(:,:,:) + delta_t*veloc_rhs(:,:,:)
     veloc(:,:,:) =  veloc(:,:,:) +  rk4b(irk) *veloc_res(:,:,:)
    

  end do

end subroutine LSERK_elastic
     

!--------------------------------------------------------



subroutine elastic_rhs()

  ! compute rigth hand side for velocity-pressure elastic wave equation 


  use global_parameters_mod
  implicit none 
  integer  :: ie, np, npf 
  

  k = norder_simu
  npf = ndof_local_face
  np =  ndof_local


! loop on elements

  do ie = 1, nE 
     
     ! compute field jump accross elements boundary
     !call elastic_field_jump(ie, npf)
     call elastic_field_jump_op(ie, npf)

     ! compute flux rhs (attention : need to do it first because of rhs vector initialisation)
     !call compute_elastic_LF_flux(ie, np, npf)
     call compute_elastic_LF_flux_op(ie, np, npf)
     ! apply derivation operators on fields and add it to rhs vector 
    
     Dr_x(:,:)=Drx(:,:,ie)
     Dr_y(:,:)=Dry(:,:,ie)
     Dr_z(:,:)=Drz(:,:,ie)
     !call compute_elastic_derivatives(ie, np)
     call compute_elastic_derivatives_op(ie, np)
     
  end do

end subroutine elastic_rhs

!------------------------------------------------------------------------


!--------------------------------------------------------------------------------------------------------------

subroutine initialise_elastic_fields()
  use global_parameters_mod
  use dd_common_mod
  use mem_alloc_mod
  implicit none

  
  write(*,*) 'Allocate Elastic  fields ' 

  call alloc_(veloc,  1, 3, 1, ndof_local, 1, nE, 'velocity field')
  call alloc_(stress, 1, 6, 1, ndof_local, 1, nE, 'pressure field')
  call alloc_(veloc_rhs,  1, 3, 1, ndof_local, 1, nE, 'velocity field rhs')
  call alloc_(stress_rhs, 1, 6, 1, ndof_local, 1, nE, 'pressure field rhs')
  call alloc_(veloc_res,  1, 3, 1, ndof_local, 1, nE, 'velocity field res')
  call alloc_(stress_res, 1, 6, 1, ndof_local, 1, nE, 'pressure field res')

  call alloc_(veloc_local,  1, 3, 1, ndof_local, 'velocity field')
  call alloc_(stress_local, 1, 6, 1, ndof_local, 'pressure field')
  call alloc_(veloc_nghb,  1, 3, 1, ndof_local, 'velocity field rhs')
  call alloc_(stress_nghb, 1, 6, 1, ndof_local, 'pressure field rhs')

  veloc(:,:,:) = 0._FP
  stress(:,:,:) = 0._FP
  veloc_rhs(:,:,:) = 0._FP
  stress_rhs(:,:,:) = 0._FP
  veloc_res(:,:,:) = 0._FP
  stress_res(:,:,:) = 0._FP
  

end subroutine initialise_elastic_fields
!--------------------------------------------------------------------------------------------------------------



subroutine elastic_field_jump(ie, npf)

  !! comupte field jump accross  boundaries between elements 
  !! will be used for flux computation

  !! note : this routine is not optimal and may be a bottleneck 

  use global_parameters_mod
  implicit none 
  integer, intent(in)   :: ie, npf 
  integer   :: indx, ifacref, ie_nghb
  integer   :: l,idof_local, ne_dof_local
  integer   :: my_dof_local
  integer   :: indx_permutted, iface_1 
  integer   :: renumerotation_faces(4)
  logical   :: tagged_face

  !! CHANGE NUMEROTATION CONVENTION (it's for debbuging)
  !! our convention -> Hesthaven's convention
  renumerotation_faces(1)=3
  renumerotation_faces(2)=4
  renumerotation_faces(3)=2 
  renumerotation_faces(4)=1
  
  indx = 0

  ! order of current element
  k=PkE(ie)

  ! loop on faces 
  do ifacref = 1, 4

     ! numerotaion used in local matrices 
     iface_1 = renumerotation_faces(ifacref)

     ! global face numerotation
     ifac = EtoF(ifacref, ie)

     ! Retrieve the neighbour element index 
     ie_nghb = sum(FtoE(1:2,ifac)) - ie
     !stress_local(:,:)= stress(:,:,ie)
     !veloc_local(:,:) = veloc(:,:,ie)
     ! test for free surface (if here NOT OPTIMAL)
     tagged_face=.false.
     if(EtoFtag(ifacref, ie) /=0 ) tagged_face=.true.
     
     ! neighbourg element
     if (ie_nghb > 0) then ! (if here NOT OPTIMAL)
        !stress_nghb(:,:)= stress(:,:,ie_nghb)
        !veloc_nghb(:,:) = veloc(:,:,ie_nghb)
        do l=1,npf  !! loop over our face

           !! next dof
           indx =indx + 1

           !! new order to consider in local matrices 
           indx_permutted = l + npf*(iface_1 - 1) 

           !! retrieve dof numerotation
           idof_local=ref_dof(k)%Ftodof(l,ifacref) 
           idof=Etodof_adj(ie) + idof_local - 1    

           !! outward normal
           nx(indx_permutted)=normal(1,idof, ifacref)
           ny(indx_permutted)=normal(2,idof, ifacref)
           nz(indx_permutted)=normal(3,idof, ifacref)
           
           !! SURFACE of ifacref
           Jface(indx_permutted) = 0.5_fp * Jacobian_2D(idof,ifacref) / weight_vol(idof) 

           !! physical parameters 
!!$           TauV(indx_permutted)= 0.5_fp * (rho(ie)*vp(ie) + rho(ie_nghb)*vp(ie_nghb))
!!$           TauP(indx_permutted)= 1._fp / TauV(indx_permutted)

           !! retrieve local dof numerotaion
           my_dof_local = dof_dof(ie)%my_local_dof(l,ifacref)  
           ne_dof_local = dof_dof(ie)%nei_local_dof(l,ifacref)


           ! compute stress jump accross interface between elements
           stress_jump_el(:,indx_permutted) = -stress(:,my_dof_local,ie) + stress(:,ne_dof_local,ie_nghb)
           !stress_jump_el(:,indx_permutted) = -stress_local(:,my_dof_local) + stress_nghb(:,ne_dof_local)

           ! compute velocity jump  accross interface between elements 
           velocity_jump_el(:,indx_permutted) = -veloc(:,my_dof_local,ie) + veloc(:,ne_dof_local,ie_nghb)
           !velocity_jump_el(:,indx_permutted) = -veloc_local(:,my_dof_local) + veloc_nghb(:,ne_dof_local)
!!$           !! precompute terms for optimization
!!$           vector1(indx_permutted) = -velocity_jump(indx_permutted) - TauP(indx_permutted) *stress_jump(indx_permutted)
!!$           vector2(indx_permutted) = -stress_jump(indx_permutted)   - TauV(indx_permutted) *velocity_jump(indx_permutted)
        end do
        
     else  ! may be free surface 

        if (tagged_face)  then

           do l=1,npf  !! loop over our face

              !! next dof
              indx =indx + 1

              !! new order to consider in local matrices
              indx_permutted = l + npf*(iface_1 - 1) 

              !! retrieve dof numerotation
              idof_local=ref_dof(k)%Ftodof(l,ifacref) 
              idof=Etodof_adj(ie) + idof_local - 1 

              !! outward normal
              nx(indx_permutted)=normal(1,idof, ifacref)
              ny(indx_permutted)=normal(2,idof, ifacref)
              nz(indx_permutted)=normal(3,idof, ifacref)
              
              !! SURFACE of ifacref
              Jface(indx_permutted) = 0.5_fp * Jacobian_2D(idof,ifacref) / weight_vol(idof) 
              
              !! physical parameters 
!!$              TauV(indx_permutted)= 0.5_fp * (rho(ie)*vp(ie) + rho(ie)*vp(ie))  
!!$              TauP(indx_permutted)= 1._fp / TauV(indx_permutted)
              
              
              !!!!! STRUCTURE
              my_dof_local = ref_dof(k)%Ftodof(l,ifacref)
             

              if (EtoFtag(ifacref,ie)==-1) then !! free surface 
                 
                 !! stress jump for free surface
                 !stress_jump_el(:,indx_permutted) = -2._fp*stress(:,my_dof_local,ie)
                 
                 stress_jump_el(:,indx_permutted) = 0._fp
                 stress_jump_el(3,indx_permutted) = -2_fp*stress(3,my_dof_local,ie)
                 stress_jump_el(5,indx_permutted) = -2_fp*stress(5,my_dof_local,ie)
                 stress_jump_el(6,indx_permutted) = -2_fp*stress(6,my_dof_local,ie)
                 !! velocity jump for free surface 
                 velocity_jump_el(:,indx_permutted) = 0._fp

                 !! try absorbing flux to debbug
                 stress_jump_el(:,indx_permutted)   =  -stress(:,my_dof_local,ie)
                 velocity_jump_el(:,indx_permutted) =  -veloc(:,my_dof_local,ie)

                 !! precompute terms for optimization
!!$                 vector1(indx_permutted) = -velocity_jump(indx_permutted) -TauP(indx_permutted) *stress_jump(indx_permutted)
!!$                 vector2(indx_permutted) = -stress_jump(indx_permutted)   -TauV(indx_permutted) *velocity_jump(indx_permutted)

              else if (EtoFtag(ifacref,ie)== 1) then ! absorbing flux
                
                 stress_jump_el(:,indx_permutted)   =  -stress(:,my_dof_local,ie)
                 velocity_jump_el(:,indx_permutted) =  -veloc(:,my_dof_local,ie)

                 !! precompute terms for optimization
!!$                 vector1(indx_permutted) = -velocity_jump(indx_permutted)-TauP(indx_permutted) *stress_jump(indx_permutted)
!!$                 vector2(indx_permutted) = -stress_jump(indx_permutted)-TauV(indx_permutted) *velocity_jump(indx_permutted)
                 

              else 
                 write(*,*) 'warning tagged face not used'

              end if
              
           end do

        end if  

     end if

  end do



end subroutine elastic_field_jump

!--------------------------------------------------------------------------------

subroutine compute_elastic_LF_flux(ie, np, npf)

  ! compute Lax-Friederich flux accross boundary

  use global_parameters_mod
  implicit none
  integer, intent(in) :: ie, np, npf
  integer  :: idof_face
  integer  :: npf4
  real(kind=fp) :: mu, lambda, lambdaP2mu, inv_rho, cp_penalty
  real(kind=fp) :: Factor_scale


  ! precompute terms
  mu =  rho(ie)*vs(ie)*vs(ie)
  lambdaP2mu = rho(ie)*vp(ie)*vp(ie)
  lambda = rho(ie)*vp(ie)*vp(ie) - 2._fp * rho(ie)*vs(ie)*vs(ie)
  inv_rho = 1._fp /rho(ie)
  cp_penalty = vp(ie)
  npf4 = 4* npf

!!! BE AWARE stress_rhs and veloc_rhs are set to 0. Not directly but by 
!!! initializing wksp before each loop for each equation
!!$  stress_rhs(:,:, ie)=0._fp
!!$  veloc_rhs(:,:, ie)=0._fp
!!$  tmp_work_vector(:,:)=0._fp
  

  ! SPLIT ALL COMPUTATION THANKS TO VTUNE AMPLIFIER ANALYSIS (speed up x 2)
  wksp(:)=0._fp !1
  do idof=1,np
     do  idof_face = 1, npf4
        Factor_scale =   Lift(idof, idof_face) * Jface(idof_face)
        wksp(idof) =  wksp(idof) + Factor_scale *( &
             lambdaP2mu * nx(idof_face) * velocity_jump_el(1,idof_face) + &
             lambda     * ny(idof_face) * velocity_jump_el(2,idof_face) + &
             lambda     * nz(idof_face) * velocity_jump_el(3,idof_face) + &
             cp_penalty * stress_jump_el(1,idof_face))
      end do
  end do
  stress_rhs(1,:, ie)= wksp(:)

  wksp(:)=0._fp !2
  do idof=1,np
     do  idof_face = 1, npf4
        Factor_scale =   Lift(idof, idof_face) * Jface(idof_face)
        wksp(idof) =  wksp(idof) + Factor_scale *( &
             lambdaP2mu * ny(idof_face) * velocity_jump_el(2,idof_face) + &
             lambda     * nx(idof_face) * velocity_jump_el(1,idof_face) + &
             lambda     * nz(idof_face) * velocity_jump_el(3,idof_face) + &
             cp_penalty * stress_jump_el(2,idof_face))
     end do
  end do
  stress_rhs(2,:, ie)= wksp(:)

  wksp(:)=0._fp !3
  do idof=1,np
     do  idof_face = 1, npf4
        Factor_scale =   Lift(idof, idof_face) * Jface(idof_face) 
        wksp(idof) = wksp(idof)  + Factor_scale *( &
             lambdaP2mu * nz(idof_face) * velocity_jump_el(3,idof_face) + &
             lambda     * nx(idof_face) * velocity_jump_el(1,idof_face) + &
             lambda     * ny(idof_face) * velocity_jump_el(2,idof_face) + &
             cp_penalty * stress_jump_el(3,idof_face))
     end do
  end do
  stress_rhs(3,:, ie)= wksp(:) 


  wksp(:)=0._fp !4
  do idof=1,np
     do  idof_face = 1, npf4
        Factor_scale =   Lift(idof, idof_face) * Jface(idof_face)
        wksp(idof) = wksp(idof) + Factor_scale *( &
             mu* ny(idof_face) * velocity_jump_el(1,idof_face) + &
             mu* nx(idof_face) * velocity_jump_el(2,idof_face) + &
             cp_penalty * stress_jump_el(4,idof_face))
     end do
  end do
  stress_rhs(4,:, ie)= wksp(:)

  wksp(:)=0._fp !5
  do idof=1,np
     do  idof_face = 1, npf4
        Factor_scale =   Lift(idof, idof_face) * Jface(idof_face)
        wksp(idof) =  wksp(idof) + Factor_scale *( &
             mu* nz(idof_face) * velocity_jump_el(1,idof_face) + &
             mu* nx(idof_face) * velocity_jump_el(3,idof_face) + &
             cp_penalty * stress_jump_el(5,idof_face))
     end do
  end do
  stress_rhs(5,:, ie)= wksp(:)

  wksp(:)=0._fp !6
  do idof=1,np
     do  idof_face = 1, npf4
        Factor_scale =   Lift(idof, idof_face) * Jface(idof_face)
        wksp(idof) = wksp(idof) + Factor_scale *( &
             mu* nz(idof_face) * velocity_jump_el(2,idof_face) + &
             mu* ny(idof_face) * velocity_jump_el(3,idof_face) + &
             cp_penalty * stress_jump_el(6,idof_face))
     end do
  end do
  stress_rhs(6,:, ie)= wksp(:)


  wksp(:)=0._fp 
  do idof=1,np
     do  idof_face = 1, npf4
        Factor_scale =   Lift(idof, idof_face) * Jface(idof_face)
        wksp(idof) = wksp(idof)  + Factor_scale *( inv_rho *  &
             (nx(idof_face) * stress_jump_el(1,idof_face)  + &
              ny(idof_face) * stress_jump_el(4,idof_face)  + &
              nz(idof_face) * stress_jump_el(5,idof_face)) + &
              cp_penalty *  velocity_jump_el(1,idof_face))
     end do
  end do
  veloc_rhs(1,:, ie)= wksp(:) 


  wksp(:)=0._fp
  do idof=1,np
     do  idof_face = 1, npf4
        Factor_scale =   Lift(idof, idof_face) * Jface(idof_face)
        wksp(idof) = wksp(idof) + Factor_scale *( inv_rho *  &
             (nx(idof_face) * stress_jump_el(4,idof_face)  + &
              ny(idof_face) * stress_jump_el(2,idof_face)  + &
              nz(idof_face) * stress_jump_el(6,idof_face)) + &
              cp_penalty *  velocity_jump_el(2,idof_face))
     end do
  end do
  veloc_rhs(2,:, ie)= wksp(:) 


  wksp(:)=0._fp
  do idof=1,np
     do  idof_face = 1, npf4
        Factor_scale =   Lift(idof, idof_face) * Jface(idof_face)
        wksp(idof) =  wksp(idof) + Factor_scale *( inv_rho *  &
             (nx(idof_face) * stress_jump_el(5,idof_face)  + &
              ny(idof_face) * stress_jump_el(6,idof_face)  + &
              nz(idof_face) * stress_jump_el(3,idof_face)) + &
              cp_penalty *  velocity_jump_el(3,idof_face))
     end do
  end do
  veloc_rhs(3,:, ie)= wksp(:) 


!! FIRST VERISION (SLOW) 
!!$  do idof=1, np
!!$     do idof_face = 1, npf4 
!!$        Factor_scale =   Lift(idof, idof_face) * Jface(idof_face)

        !stress_rhs(1,idof,ie) = stress_rhs(1,idof, ie) +   Factor_scale *( &
!!$        tmp_work_vector(1,idof) = tmp_work_vector(1,idof) + Factor_scale *( &
!!$             lambdaP2mu * nx(idof_face) * velocity_jump_el(1,idof_face) + &
!!$             lambda     * ny(idof_face) * velocity_jump_el(2,idof_face) + &
!!$             lambda     * nz(idof_face) * velocity_jump_el(3,idof_face) + &
!!$             cp_penalty * stress_jump_el(1,idof_face))

        !stress_rhs(2,idof,ie) = stress_rhs(2,idof, ie) +   Factor_scale *( &
!!$        tmp_work_vector(2,idof) = tmp_work_vector(2,idof) + Factor_scale *( &
!!$             lambdaP2mu * ny(idof_face) * velocity_jump_el(2,idof_face) + &
!!$             lambda     * nx(idof_face) * velocity_jump_el(1,idof_face) + &
!!$             lambda     * nz(idof_face) * velocity_jump_el(3,idof_face) + &
!!$             cp_penalty * stress_jump_el(2,idof_face))

        !stress_rhs(3,idof,ie) = stress_rhs(3,idof, ie) +   Factor_scale *( &
!!$        tmp_work_vector(3,idof) = tmp_work_vector(3,idof) + Factor_scale *( &
!!$             lambdaP2mu * nz(idof_face) * velocity_jump_el(3,idof_face) + &
!!$             lambda     * nx(idof_face) * velocity_jump_el(1,idof_face) + &
!!$             lambda     * ny(idof_face) * velocity_jump_el(2,idof_face) + &
!!$             cp_penalty * stress_jump_el(3,idof_face))

        !stress_rhs(4,idof,ie) = stress_rhs(4,idof, ie) +   Factor_scale *( &
!!$        tmp_work_vector(4,idof) = tmp_work_vector(4,idof) + Factor_scale *( &
!!$             mu* ny(idof_face) * velocity_jump_el(1,idof_face) + &
!!$             mu* nx(idof_face) * velocity_jump_el(2,idof_face) + &
!!$             cp_penalty * stress_jump_el(4,idof_face))

        !stress_rhs(5,idof,ie) = stress_rhs(5,idof, ie) +    Factor_scale *( &
!!$        tmp_work_vector(5,idof) = tmp_work_vector(5,idof) + Factor_scale *( &
!!$             mu* nz(idof_face) * velocity_jump_el(1,idof_face) + &
!!$             mu* nx(idof_face) * velocity_jump_el(3,idof_face) + &
!!$             cp_penalty * stress_jump_el(5,idof_face))

        !stress_rhs(6,idof,ie) = stress_rhs(6,idof, ie) +    Factor_scale *( &
!!$        tmp_work_vector(6,idof) = tmp_work_vector(6,idof) + Factor_scale *( &
!!$             mu* nz(idof_face) * velocity_jump_el(2,idof_face) + &
!!$             mu* ny(idof_face) * velocity_jump_el(3,idof_face) + &
!!$             cp_penalty * stress_jump_el(6,idof_face))

        !veloc_rhs(1,idof, ie) = veloc_rhs(1,idof, ie)  +  Factor_scale * ( inv_rho *&
!!$        tmp_work_vector(7,idof) = tmp_work_vector(7,idof) + Factor_scale *( inv_rho *&
!!$             (nx(idof_face) * stress_jump_el(1,idof_face) + &
!!$              ny(idof_face) * stress_jump_el(4,idof_face) + &
!!$              nz(idof_face) * stress_jump_el(5,idof_face)) + &
!!$              cp_penalty *  velocity_jump_el(1,idof_face))

        !veloc_rhs(2,idof, ie) = veloc_rhs(2,idof, ie)  +  Factor_scale * ( inv_rho *&
!!$        tmp_work_vector(8,idof) = tmp_work_vector(8,idof) + Factor_scale *( inv_rho *&
!!$             (nx(idof_face) * stress_jump_el(4,idof_face) + &
!!$              ny(idof_face) * stress_jump_el(2,idof_face)  + &
!!$              nz(idof_face) * stress_jump_el(6,idof_face)) + &
!!$              cp_penalty *  velocity_jump_el(2,idof_face))

        !veloc_rhs(3,idof, ie) = veloc_rhs(3,idof, ie)  +  Factor_scale * ( inv_rho *&
!!$        tmp_work_vector(9,idof) = tmp_work_vector(9,idof) + Factor_scale *( inv_rho *&
!!$             (nx(idof_face) * stress_jump_el(5,idof_face)  + &
!!$              ny(idof_face) * stress_jump_el(6,idof_face)  + &
!!$              nz(idof_face) * stress_jump_el(3,idof_face)) + &
!!$              cp_penalty *  velocity_jump_el(3,idof_face))


!!$     end do
!!$  end do
  
!!$  stress_rhs(:,:, ie) = tmp_work_vector(1:6,:)
!!$  veloc_rhs(:,:, ie) = tmp_work_vector(7:9,:)
  

end subroutine compute_elastic_LF_flux

!-----------------------------------------------------------------

subroutine compute_elastic_derivatives(ie, np)
  use global_parameters_mod
  implicit none
  integer, intent(in) :: ie, np
  integer  :: jdof
  integer  :: npf4
  real(kind=fp) :: mu, lambda, lambdaP2mu, inv_rho
  
  mu =  rho(ie)*vs(ie)*vs(ie)
  lambdaP2mu = rho(ie)*vp(ie)*vp(ie)
  lambda = rho(ie)*vp(ie)*vp(ie) - 2._fp * rho(ie)*vs(ie)*vs(ie)
  inv_rho = 1._fp /rho(ie)
  
!!! SPLIT ALL COMPUTATION 
  wksp(:)=stress_rhs(1,:, ie)
  do idof = 1, np
     do jdof = 1, np
        wksp(idof) = wksp(idof) + &
             lambdaP2mu *Dr_x(idof,jdof)* veloc(1,jdof, ie) + &
             lambda     *Dr_y(idof,jdof)* veloc(2,jdof, ie) + &
             lambda     *Dr_z(idof,jdof)* veloc(3,jdof, ie)
     end do
  end do
  stress_rhs(1,:, ie)=wksp(:)


  wksp(:)=stress_rhs(2,:, ie)
  do idof = 1, np
     do jdof = 1, np
        wksp(idof) = wksp(idof) + &
             lambdaP2mu *Dr_y(idof,jdof)* veloc(2,jdof, ie) + &
             lambda     *Dr_x(idof,jdof)* veloc(1,jdof, ie) + &
             lambda     *Dr_z(idof,jdof)* veloc(3,jdof, ie)
     end do
  end do
  stress_rhs(2,:, ie)=wksp(:)     

  wksp(:)=stress_rhs(3,:, ie)
  do idof = 1, np
     do jdof = 1, np
        wksp(idof) = wksp(idof) + &
             lambdaP2mu *Dr_z(idof,jdof)* veloc(3,jdof, ie) + &
             lambda     *Dr_x(idof,jdof)* veloc(1,jdof, ie) + &
             lambda     *Dr_y(idof,jdof)* veloc(2,jdof, ie)
     end do
  end do
  stress_rhs(3,:, ie)=wksp(:)     

  wksp(:)=stress_rhs(4,:, ie)
  do idof = 1, np
     do jdof = 1, np
        wksp(idof) = wksp(idof) + mu* ( &
             Dr_y(idof,jdof)* veloc(1,jdof, ie) + &
             Dr_x(idof,jdof)* veloc(2,jdof, ie))  
             
     end do
  end do
  stress_rhs(4,:, ie)=wksp(:)     

  wksp(:)=stress_rhs(5,:, ie)
  do idof = 1, np
     do jdof = 1, np
        wksp(idof) = wksp(idof)  + mu* ( &
             Dr_z(idof,jdof)* veloc(1,jdof, ie) + &
             Dr_x(idof,jdof)* veloc(3,jdof, ie))
     end do
  end do
  stress_rhs(5,:, ie)=wksp(:)     


  wksp(:)=stress_rhs(6,:, ie)
  do idof = 1, np
     do jdof = 1, np
        wksp(idof) = wksp(idof) +  mu* ( &
             Dr_z(idof,jdof)* veloc(2,jdof, ie) + &
             Dr_y(idof,jdof)* veloc(3,jdof, ie))
     end do
  end do
  stress_rhs(6,:, ie)=wksp(:)    
 
  wksp(:)=veloc_rhs(1,:, ie)
  do idof = 1, np
     do jdof = 1, np
        wksp(idof) = wksp(idof) +  inv_rho*(&
             Dr_x(idof,jdof)*stress(1,jdof, ie) + &
             Dr_y(idof,jdof)*stress(4,jdof, ie) + &
             Dr_z(idof,jdof)*stress(5,jdof, ie))
     end do
  end do
  veloc_rhs(1,:, ie)=wksp(:)     

  wksp(:)=veloc_rhs(2,:, ie)
  do idof = 1, np
     do jdof = 1, np
        wksp(idof) = wksp(idof) +  inv_rho*(&
             Dr_x(idof,jdof)*stress(4,jdof, ie) + &
             Dr_y(idof,jdof)*stress(2,jdof, ie) + &
             Dr_z(idof,jdof)*stress(6,jdof, ie))
     end do
  end do
  veloc_rhs(2,:, ie)=wksp(:)

  wksp(:)=veloc_rhs(3,:, ie)
  do idof = 1, np
     do jdof = 1, np
        wksp(idof) = wksp(idof) +  inv_rho*(&
             Dr_x(idof,jdof)*stress(5,jdof, ie) + &
             Dr_y(idof,jdof)*stress(6,jdof, ie) + &
             Dr_z(idof,jdof)*stress(3,jdof, ie))
     end do
  end do
  veloc_rhs(3,:, ie)=wksp(:)

!!!

!!$  do idof = 1, np
!!$     do jdof = 1, np
!!$       
!!$        stress_rhs(1,idof, ie) = stress_rhs(1,idof, ie) + &
!!$             lambdaP2mu *Dr_x(idof, jdof)* veloc(1,jdof, ie) + &
!!$             lambda     *Dr_y(idof, jdof)* veloc(2,jdof, ie) + &
!!$             lambda     *Dr_z(idof, jdof)* veloc(3,jdof, ie)
!!$
!!$        stress_rhs(2,idof, ie) = stress_rhs(2,idof, ie) + &
!!$             lambdaP2mu *Dr_y(idof, jdof)* veloc(2,jdof, ie) + &
!!$             lambda     *Dr_x(idof, jdof)* veloc(1,jdof, ie) + &
!!$             lambda     *Dr_z(idof, jdof)* veloc(3,jdof, ie)
!!$        
!!$        stress_rhs(3,idof, ie) = stress_rhs(3,idof, ie) + &
!!$             lambdaP2mu *Dr_z(idof, jdof)* veloc(3,jdof, ie) + &
!!$             lambda     *Dr_x(idof, jdof)* veloc(1,jdof, ie) + &
!!$             lambda     *Dr_y(idof, jdof)* veloc(2,jdof, ie)
!!$
!!$        stress_rhs(4,idof, ie) = stress_rhs(4,idof, ie) + mu* ( &
!!$                        Dr_y(idof, jdof)* veloc(1,jdof, ie) + &
!!$                        Dr_x(idof, jdof)* veloc(2,jdof, ie)) 
!!$
!!$        stress_rhs(5,idof, ie) = stress_rhs(5,idof, ie) + mu* ( &
!!$                        Dr_z(idof, jdof)* veloc(1,jdof, ie) + &
!!$                        Dr_x(idof, jdof)* veloc(3,jdof, ie)) 
!!$        
!!$        stress_rhs(6,idof, ie) = stress_rhs(6,idof, ie) + mu* ( &
!!$                        Dr_z(idof, jdof)* veloc(2,jdof, ie) + &
!!$                        Dr_y(idof, jdof)* veloc(3,jdof, ie))
!!$
!!$        veloc_rhs(1,idof, ie) = veloc_rhs(1,idof, ie) + inv_rho*(&
!!$             Dr_x(idof, jdof)*stress(1,jdof, ie) + &
!!$             Dr_y(idof, jdof)*stress(4,jdof, ie) + &
!!$             Dr_z(idof, jdof)*stress(5,jdof, ie))
!!$       
!!$        veloc_rhs(2,idof, ie) = veloc_rhs(2,idof, ie) + inv_rho*(&
!!$             Dr_x(idof, jdof)*stress(4,jdof, ie) + &
!!$             Dr_y(idof, jdof)*stress(2,jdof, ie) + &
!!$             Dr_z(idof, jdof)*stress(6,jdof, ie))
!!$
!!$        veloc_rhs(3,idof, ie) = veloc_rhs(3,idof, ie) + inv_rho*(&
!!$             Dr_x(idof, jdof)*stress(5,jdof, ie) + &
!!$             Dr_y(idof, jdof)*stress(6,jdof, ie) + &
!!$             Dr_z(idof, jdof)*stress(3,jdof, ie))
!!$
!!$
!!$     end do
!!$  end do
end subroutine compute_elastic_derivatives

subroutine define_block_matrices(ie, np, npf)

  use global_parameters_mod
  implicit none

  integer,             intent(in)   :: ie, np, npf
  
  integer   :: indx, ifacref, ie_nghb, npf4
  integer   :: l,idof_local, ne_dof_local
  integer   :: my_dof_local, idof_face
  integer   :: indx_permutted, iface_1
  integer   :: ilin, icol, jdof
  integer   :: renumerotation_faces(4)
  logical   :: tagged_face
  real(kind=fp) :: mu, lambda, lambdaP2mu, inv_rho

  !! CHANGE NUMEROTATION CONVENTION (it's for debbuging)
  !! our convention -> Hesthaven's convention
  renumerotation_faces(1)=3
  renumerotation_faces(2)=4
  renumerotation_faces(3)=2 
  renumerotation_faces(4)=1
  
  flux(:)=0
  indx_to_use(:,:)=0
  indx_face_ref(:)=0
  Mfl(:,:,:)=0._fp
  Mds(:,:)=0._fp

  ! precompute terms
  mu =  rho(ie)*vs(ie)*vs(ie)
  lambdaP2mu = rho(ie)*vp(ie)*vp(ie)
  lambda = rho(ie)*vp(ie)*vp(ie) - 2._fp * rho(ie)*vs(ie)*vs(ie)
  inv_rho = 1._fp /rho(ie)
  npf4=4*npf

  indx = 0

  ! order of current element
  k=PkE(ie)

  ! loop on faces 
  do ifacref = 1, 4

     ! numerotaion used in local matrices 
     iface_1 = renumerotation_faces(ifacref)
     
     ! global face numerotation
     ifac = EtoF(ifacref, ie)

     ! Retrieve the neighbour element index 
     ie_nghb = sum(FtoE(1:2,ifac)) - ie
     !stress_local(:,:)= stress(:,:,ie)
     !veloc_local(:,:) = veloc(:,:,ie)
     ! test for free surface (if here NOT OPTIMAL)
     tagged_face=.false.
      ! test for free surface (if here NOT OPTIMAL)
     tagged_face=.false.
     if(EtoFtag(ifacref, ie) /=0 ) tagged_face=.true.
     
     ! neighbourg element
     if (ie_nghb > 0) then ! (if here NOT OPTIMAL)
        !stress_nghb(:,:)= stress(:,:,ie_nghb)
        !veloc_nghb(:,:) = veloc(:,:,ie_nghb)
        do l=1,npf  !! loop over our face

           !! next dof
           indx =indx + 1

           !! new order to consider in local matrices 
           indx_permutted = l + npf*(iface_1 - 1) 

           !! retrieve dof numerotation
           idof_local=ref_dof(k)%Ftodof(l,ifacref) 
           idof=Etodof_adj(ie) + idof_local - 1    

           !! outward normal
           nx(indx_permutted)=normal(1,idof, ifacref)
           ny(indx_permutted)=normal(2,idof, ifacref)
           nz(indx_permutted)=normal(3,idof, ifacref)
                     
           !! SURFACE of ifacref
           Jface(indx_permutted) = 0.5_fp * Jacobian_2D(idof,ifacref) / weight_vol(idof) 

           !! physical parameters 
!!$           TauV(indx_permutted)= 0.5_fp * (rho(ie)*vp(ie) + rho(ie_nghb)*vp(ie_nghb))
!!$           TauP(indx_permutted)= 1._fp / TauV(indx_permutted)

           !! retrieve local dof numerotaion
           my_dof_local = dof_dof(ie)%my_local_dof(l,ifacref)  
           ne_dof_local = dof_dof(ie)%nei_local_dof(l,ifacref)

           flux(indx_permutted)=1
           indx_to_use(1,indx_permutted)=my_dof_local
           indx_to_use(2,indx_permutted)=ne_dof_local
           indx_face_ref(indx_permutted)=ifacref


           ! compute stress jump accross interface between elements
           stress_jump_el(:,indx_permutted) = -stress(:,my_dof_local,ie) + stress(:,ne_dof_local,ie_nghb)
           !stress_jump_el(:,indx_permutted) = -stress_local(:,my_dof_local) + stress_nghb(:,ne_dof_local)

           ! compute velocity jump  accross interface between elements 
           velocity_jump_el(:,indx_permutted) = -veloc(:,my_dof_local,ie) + veloc(:,ne_dof_local,ie_nghb)
        end do
     else  ! may be free surface 
                  
        if (tagged_face)  then
           
           do l=1,npf  !! loop over our face
              
              !! next dof
              indx =indx + 1
              
              !! new order to consider in local matrices
              indx_permutted = l + npf*(iface_1 - 1) 
              
              !! retrieve dof numerotation
              idof_local=ref_dof(k)%Ftodof(l,ifacref) 
              idof=Etodof_adj(ie) + idof_local - 1 
              
              !! outward normal
              nx(indx_permutted)=normal(1,idof, ifacref)
              ny(indx_permutted)=normal(2,idof, ifacref)
              nz(indx_permutted)=normal(3,idof, ifacref)
              
              !! SURFACE of ifacref
              Jface(indx_permutted) = 0.5_fp * Jacobian_2D(idof,ifacref) / weight_vol(idof) 
              !
              my_dof_local = ref_dof(k)%Ftodof(l,ifacref)
              
              indx_to_use(1,indx_permutted)=my_dof_local
              indx_to_use(2,indx_permutted)=0
             
              if (EtoFtag(ifacref,ie)==-1) then !! free surface 
                 
                 !! stress jump for free surface
                 !stress_jump_el(:,indx_permutted) = -2._fp*stress(:,my_dof_local,ie)
                 flux(indx_permutted) = 2
                 stress_jump_el(:,indx_permutted) = 0._fp
                 stress_jump_el(3,indx_permutted) = -2_fp*stress(3,my_dof_local,ie)
                 stress_jump_el(5,indx_permutted) = -2_fp*stress(5,my_dof_local,ie)
                 stress_jump_el(6,indx_permutted) = -2_fp*stress(6,my_dof_local,ie)
                 !! velocity jump for free surface 
                 velocity_jump_el(:,indx_permutted) = 0._fp
                    
                 !! try boundary flux to debbug
                 stress_jump_el(:,indx_permutted)   =  -stress(:,my_dof_local,ie)
                 velocity_jump_el(:,indx_permutted) =  -veloc(:,my_dof_local,ie)
                 
              else if (EtoFtag(ifacref,ie)== 1) then ! absorbing flux
                 
                 flux(indx_permutted)=3
                 stress_jump_el(:,indx_permutted)   =  -stress(:,my_dof_local,ie)
                 velocity_jump_el(:,indx_permutted) =  -veloc(:,my_dof_local,ie)
                 
              else 
                 write(*,*) 'warning tagged face not used'
                 
              end if
              
           end do
           
        end if
        
     end if
     
  end do
  

  !! matrix for ie element
  Mds(:,:)=0._fp
  do idof = 1, np
      
     do jdof = 1, np

         !! eq 1
         ilin = 1 + 9*(idof-1)
         icol = 4 + 9*(idof-1)
         Mds(ilin, icol)  = inv_rho*Dr_x(idof,jdof)
         icol = 7 + 9*(idof-1)
         Mds(ilin, icol)  = inv_rho*Dr_y(idof,jdof)
         icol = 8 + 9*(idof-1)
         Mds(ilin, icol)  = inv_rho*Dr_z(idof,jdof)

         !! eq 2
         ilin = 2 + 9*(idof-1)
         icol = 5 + 9*(idof-1)
         Mds(ilin, icol)  = inv_rho*Dr_y(idof,jdof)
         icol = 7 + 9*(idof-1)
         Mds(ilin, icol)  = inv_rho*Dr_x(idof,jdof)
         icol = 9 + 9*(idof-1)
         Mds(ilin, icol)  = inv_rho*Dr_z(idof,jdof)
         
         !! eq 3
         ilin = 3 + 9*(idof-1)
         icol = 6 + 9*(idof-1)
         Mds(ilin, icol)  = inv_rho*Dr_z(idof,jdof)
         icol = 8 + 9*(idof-1)
         Mds(ilin, icol)  = inv_rho*Dr_x(idof,jdof)
         icol = 9 + 9*(idof-1)
         Mds(ilin, icol)  = inv_rho*Dr_y(idof,jdof)

         !! eq 4
         ilin=4 + 9*(idof-1)
         icol=1 + 9*(jdof-1)
         Mds(ilin, icol)  = lambdaP2mu *Dr_x(idof,jdof)
         icol=2 + 9*(jdof-1)
         Mds(ilin, icol)  =  lambda    *Dr_y(idof,jdof)
         icol=3 + 9*(jdof-1)
         Mds(ilin, icol)  =  lambda    *Dr_z(idof,jdof)
        
         
         !! eq 5
         ilin=5 + 9*(idof-1)
         icol=1 + 9*(jdof-1)
         Mds(ilin, icol)  =  lambda      *Dr_x(idof,jdof)
         icol=2 + 9*(jdof-1)
         Mds(ilin, icol)  =  lambdaP2mu  *Dr_y(idof,jdof)
         icol=3 + 9*(jdof-1)
         Mds(ilin, icol)  =  lambda      *Dr_z(idof,jdof)

         !! eq 6
         ilin=6 + 9*(idof-1)
         icol=1 + 9*(jdof-1)
         Mds(ilin, icol)  =  lambda      *Dr_x(idof,jdof)
         icol=2 + 9*(jdof-1)
         Mds(ilin, icol)  =  lambda      *Dr_y(idof,jdof)
         icol=3 + 9*(jdof-1)
         Mds(ilin, icol)  =  lambdaP2mu  *Dr_z(idof,jdof)

         !! eq 7
         ilin=7 + 9*(idof-1)
         icol=1 + 9*(jdof-1)
         Mds(ilin, icol)  =   mu         *Dr_y(idof,jdof)
         icol=2 + 9*(jdof-1)
         Mds(ilin, icol)  =   mu         *Dr_x(idof,jdof)

         !! eq 8
         ilin=8 + 9*(idof-1)
         icol=1 + 9*(jdof-1)
         Mds(ilin, icol)  =   mu         *Dr_z(idof,jdof)
         icol=3 + 9*(jdof-1)
         Mds(ilin, icol)  =   mu         *Dr_x(idof,jdof)
         
         !! eq 9
         ilin=9 + 9*(idof-1)
         icol=2 + 9*(jdof-1)
         Mds(ilin, icol)  =   mu         *Dr_z(idof,jdof)
         icol=3 + 9*(jdof-1)
         Mds(ilin, icol)  =   mu         *Dr_y(idof,jdof)      
         

     end do
  end do




  ! fluxes on internal face
  do idof=1,np
     do idof_face=1,npf4
            
        jdof = indx_to_use(1,idof_face)
       
        select case (flux(idof_face))
        case(1) ! internal flux

           ! eq 1 
           ilin = 1 + 9*(idof-1)
           icol = 4 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) -  Lift(idof, idof_face) * Jface(idof_face) * inv_rho * nx(idof_face)
           icol = 7 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) -  Lift(idof, idof_face) * Jface(idof_face) * inv_rho * ny(idof_face)
           icol = 8 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) -  Lift(idof, idof_face) * Jface(idof_face) * inv_rho * nz(idof_face)

           ! eq 2
           ilin = 2 + 9*(idof-1)
           icol = 5 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) -  Lift(idof, idof_face) * Jface(idof_face) * inv_rho * ny(idof_face)
           icol = 7 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) -  Lift(idof, idof_face) * Jface(idof_face) * inv_rho * nx(idof_face)
           icol = 9 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) -  Lift(idof, idof_face) * Jface(idof_face) * inv_rho * nz(idof_face)

           ! eq 3
           ilin = 3 + 9*(idof-1)
           icol = 6 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) -  Lift(idof, idof_face) * Jface(idof_face) * inv_rho * nz(idof_face)
           icol = 8 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) -  Lift(idof, idof_face) * Jface(idof_face) * inv_rho * nx(idof_face)
           icol = 9 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) -  Lift(idof, idof_face) * Jface(idof_face) * inv_rho * ny(idof_face)

           ! eq 4
           ilin = 4 + 9*(idof-1)
           icol = 1 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) -  Lift(idof, idof_face) * Jface(idof_face)* lambdaP2mu * nx(idof_face)
           icol = 2 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) -  Lift(idof, idof_face) * Jface(idof_face)* lambda * ny(idof_face)
           icol = 3 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) -  Lift(idof, idof_face) * Jface(idof_face)* lambda * nz(idof_face)

           ! eq 5
           ilin = 5 + 9*(idof-1)
           icol = 1 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) -  Lift(idof, idof_face) * Jface(idof_face)* lambda* nx(idof_face)
           icol = 2 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) -  Lift(idof, idof_face) * Jface(idof_face)* lambdaP2mu * ny(idof_face)
           icol = 3 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) -  Lift(idof, idof_face) * Jface(idof_face)* lambda * nz(idof_face)
 
           ! eq 6
           ilin = 6 + 9*(idof-1)
           icol = 1 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) -  Lift(idof, idof_face) * Jface(idof_face)* lambda* nx(idof_face)
           icol = 2 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) -  Lift(idof, idof_face) * Jface(idof_face)* lambda * ny(idof_face)
           icol = 3 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) -  Lift(idof, idof_face) * Jface(idof_face)* lambdaP2mu * nz(idof_face)

           ! eq 7
           ilin = 7 + 9*(idof-1)
           icol = 1 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) - Lift(idof, idof_face) * Jface(idof_face) * mu* ny(idof_face)
           icol = 2 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) - Lift(idof, idof_face) * Jface(idof_face) * mu* nx(idof_face)
           
           ! eq 8
           ilin = 8 + 9*(idof-1)
           icol = 1 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) - Lift(idof, idof_face) * Jface(idof_face) * mu* nz(idof_face)
           icol = 3 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) - Lift(idof, idof_face) * Jface(idof_face) * mu* nx(idof_face)
           
           ! eq 9
           ilin = 9 + 9*(idof-1)
           icol = 2 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) - Lift(idof, idof_face) * Jface(idof_face) * mu* nz(idof_face)
           icol = 3 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) - Lift(idof, idof_face) * Jface(idof_face) * mu* ny(idof_face)

          
           
        case(2) ! free surface
          ! eq 1-2-3 : stress==-2stess
           ! eq 1 
           ilin = 1 + 9*(idof-1)
           icol = 4 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) - 2._fp * Lift(idof, idof_face) * Jface(idof_face) * inv_rho * nx(idof_face)
           icol = 7 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) - 2._fp * Lift(idof, idof_face) * Jface(idof_face) * inv_rho * ny(idof_face)
           icol = 8 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) - 2._fp * Lift(idof, idof_face) * Jface(idof_face) * inv_rho * nz(idof_face)

           ! eq 2
           ilin = 2 + 9*(idof-1)
           icol = 5 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) - 2._fp * Lift(idof, idof_face) * Jface(idof_face) * inv_rho * ny(idof_face)
           icol = 7 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) - 2._fp * Lift(idof, idof_face) * Jface(idof_face) * inv_rho * nx(idof_face)
           icol = 9 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) - 2._fp * Lift(idof, idof_face) * Jface(idof_face) * inv_rho * nz(idof_face)

           ! eq 3
           ilin = 3 + 9*(idof-1)
           icol = 6 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) - 2._fp * Lift(idof, idof_face) * Jface(idof_face) * inv_rho * nz(idof_face)
           icol = 8 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) - 2._fp * Lift(idof, idof_face) * Jface(idof_face) * inv_rho * nx(idof_face)
           icol = 9 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) - 2._fp * Lift(idof, idof_face) * Jface(idof_face) * inv_rho * ny(idof_face)

          ! eq 4-5-6-7-8-9 : veloc==0
          
        case(3) ! absorbing boundary
           ! eq 1-2-3 : stress=-stress
           ! eq 4-5-6-7-8-9 : veloc = -veloc
           ! eq 1 
           ilin = 1 + 9*(idof-1)
           icol = 4 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) -  Lift(idof, idof_face) * Jface(idof_face) * inv_rho * nx(idof_face)
           icol = 7 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) -  Lift(idof, idof_face) * Jface(idof_face) * inv_rho * ny(idof_face)
           icol = 8 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) -  Lift(idof, idof_face) * Jface(idof_face) * inv_rho * nz(idof_face)

           ! eq 2
           ilin = 2 + 9*(idof-1)
           icol = 5 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) -  Lift(idof, idof_face) * Jface(idof_face) * inv_rho * ny(idof_face)
           icol = 7 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) -  Lift(idof, idof_face) * Jface(idof_face) * inv_rho * nx(idof_face)
           icol = 9 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) -  Lift(idof, idof_face) * Jface(idof_face) * inv_rho * nz(idof_face)

           ! eq 3
           ilin = 3 + 9*(idof-1)
           icol = 6 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) -  Lift(idof, idof_face) * Jface(idof_face) * inv_rho * nz(idof_face)
           icol = 8 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) -  Lift(idof, idof_face) * Jface(idof_face) * inv_rho * nx(idof_face)
           icol = 9 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) -  Lift(idof, idof_face) * Jface(idof_face) * inv_rho * ny(idof_face)

           ! eq 4
           ilin = 4 + 9*(idof-1)
           icol = 1 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) -  Lift(idof, idof_face) * Jface(idof_face)* lambdaP2mu * nx(idof_face)
           icol = 2 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) -  Lift(idof, idof_face) * Jface(idof_face)* lambda * ny(idof_face)
           icol = 3 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) -  Lift(idof, idof_face) * Jface(idof_face)* lambda * nz(idof_face)

           ! eq 5
           ilin = 5 + 9*(idof-1)
           icol = 1 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) -  Lift(idof, idof_face) * Jface(idof_face)* lambda* nx(idof_face)
           icol = 2 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) -  Lift(idof, idof_face) * Jface(idof_face)* lambdaP2mu * ny(idof_face)
           icol = 3 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) -  Lift(idof, idof_face) * Jface(idof_face)* lambda * nz(idof_face)
 
           ! eq 6
           ilin = 6 + 9*(idof-1)
           icol = 1 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) -  Lift(idof, idof_face) * Jface(idof_face)* lambda* nx(idof_face)
           icol = 2 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) -  Lift(idof, idof_face) * Jface(idof_face)* lambda * ny(idof_face)
           icol = 3 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) -  Lift(idof, idof_face) * Jface(idof_face)* lambdaP2mu * nz(idof_face)

           ! eq 7
           ilin = 7 + 9*(idof-1)
           icol = 1 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) - Lift(idof, idof_face) * Jface(idof_face) * mu* ny(idof_face)
           icol = 2 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) - Lift(idof, idof_face) * Jface(idof_face) * mu* nx(idof_face)
        
           ! eq 8
           ilin = 8 + 9*(idof-1)
           icol = 1 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) - Lift(idof, idof_face) * Jface(idof_face) * mu* nz(idof_face)
           icol = 3 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) - Lift(idof, idof_face) * Jface(idof_face) * mu* nx(idof_face)
           
           ! eq 9
           ilin = 9 + 9*(idof-1)
           icol = 2 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) - Lift(idof, idof_face) * Jface(idof_face) * mu* nz(idof_face)
           icol = 3 + 9*(jdof-1)
           Mds(ilin, icol) = Mds(ilin, icol) - Lift(idof, idof_face) * Jface(idof_face) * mu* ny(idof_face)

        end select
     end do
  end do

  Mfl(:,:,:)=0._fp
  ! Mfl(ilin,icol,ifacref,ie) : Matrix FLuxes on external element boundary
  do idof=1,np
     do idof_face = 1, npf4

        jdof    = indx_to_use(2,idof_face)
        ifacref = indx_face_ref(idof_face)

        ! eq 1 
        ilin = 1 + 9*(idof-1)
        icol = 4 + 9*(jdof-1)
        Mfl(ilin, icol, ifacref) = Lift(idof, idof_face) * Jface(idof_face) * inv_rho * nx(idof_face)
        icol = 7 + 9*(jdof-1)
        Mfl(ilin, icol, ifacref) = Lift(idof, idof_face) * Jface(idof_face) * inv_rho * ny(idof_face)
        icol = 8 + 9*(jdof-1)
        Mfl(ilin, icol, ifacref) = Lift(idof, idof_face) * Jface(idof_face) * inv_rho * nz(idof_face)

        ! eq 2
        ilin = 2 + 9*(idof-1)
        icol = 5 + 9*(jdof-1)
        Mfl(ilin, icol, ifacref) = Lift(idof, idof_face) * Jface(idof_face) * inv_rho * ny(idof_face)
        icol = 7 + 9*(jdof-1)
        Mfl(ilin, icol, ifacref) = Lift(idof, idof_face) * Jface(idof_face) * inv_rho * nx(idof_face)
        icol = 9 + 9*(jdof-1)
        Mfl(ilin, icol, ifacref) = Lift(idof, idof_face) * Jface(idof_face) * inv_rho * nz(idof_face)
        
        ! eq 3
        ilin = 3 + 9*(idof-1)
        icol = 6 + 9*(jdof-1)
        Mfl(ilin, icol, ifacref) = Lift(idof, idof_face) * Jface(idof_face) * inv_rho * nz(idof_face)
        icol = 8 + 9*(jdof-1)
        Mfl(ilin, icol, ifacref) = Lift(idof, idof_face) * Jface(idof_face) * inv_rho * nx(idof_face)
        icol = 9 + 9*(jdof-1)
        Mfl(ilin, icol, ifacref) = Lift(idof, idof_face) * Jface(idof_face) * inv_rho * ny(idof_face)

        ! eq 4
        ilin = 4 + 9*(idof-1)
        icol = 1 + 9*(jdof-1)
        Mfl(ilin, icol, ifacref) = Lift(idof, idof_face) * Jface(idof_face)* lambdaP2mu * nx(idof_face)
        icol = 2 + 9*(jdof-1)
        Mfl(ilin, icol, ifacref) = Lift(idof, idof_face) * Jface(idof_face)* lambda * ny(idof_face)
        icol = 3 + 9*(jdof-1)
        Mfl(ilin, icol, ifacref) = Lift(idof, idof_face) * Jface(idof_face)* lambda * nz(idof_face)
        
        ! eq 5
        ilin = 5 + 9*(idof-1)
        icol = 1 + 9*(jdof-1)
        Mfl(ilin, icol,ifacref) = Lift(idof, idof_face) * Jface(idof_face)* lambda* nx(idof_face)
        icol = 2 + 9*(jdof-1)
        Mfl(ilin, icol, ifacref) = Lift(idof, idof_face) * Jface(idof_face)* lambdaP2mu * ny(idof_face)
        icol = 3 + 9*(jdof-1)
        Mfl(ilin, icol,ifacref) = Lift(idof, idof_face) * Jface(idof_face)* lambda * nz(idof_face)
        
        ! eq 6
        ilin = 6 + 9*(idof-1)
        icol = 1 + 9*(jdof-1)
        Mfl(ilin, icol,ifacref) = Lift(idof, idof_face) * Jface(idof_face)* lambda* nx(idof_face)
        icol = 2 + 9*(jdof-1)
        Mfl(ilin, icol,ifacref) = Lift(idof, idof_face) * Jface(idof_face)* lambda * ny(idof_face)
        icol = 3 + 9*(jdof-1)
        Mfl(ilin, icol, ifacref) = Lift(idof, idof_face) * Jface(idof_face)* lambdaP2mu * nz(idof_face)
        
        ! eq 7
        ilin = 7 + 9*(idof-1)
        icol = 1 + 9*(jdof-1)
        Mfl(ilin, icol,  ifacref) = Lift(idof, idof_face) * Jface(idof_face) * mu* ny(idof_face)
        icol = 2 + 9*(jdof-1)
        Mfl(ilin, icol,  ifacref) = Lift(idof, idof_face) * Jface(idof_face) * mu* nx(idof_face)
        
        ! eq 8
        ilin = 8 + 9*(idof-1)
        icol = 1 + 9*(jdof-1)
        Mfl(ilin, icol, ifacref) = Lift(idof, idof_face) * Jface(idof_face) * mu* nz(idof_face)
        icol = 3 + 9*(jdof-1)
        Mfl(ilin, icol, ifacref) = Lift(idof, idof_face) * Jface(idof_face) * mu* nx(idof_face)
        
        ! eq 9
        ilin = 9 + 9*(idof-1)
        icol = 2 + 9*(jdof-1)
        Mfl(ilin, icol, ifacref) = Lift(idof, idof_face) * Jface(idof_face) * mu* nz(idof_face)
        icol = 3 + 9*(jdof-1)
        Mfl(ilin, icol, ifacref) = Lift(idof, idof_face) * Jface(idof_face) * mu* ny(idof_face)
   
     end do
  end do
end subroutine define_block_matrices

subroutine allocate_block_matrix_arrays

  use global_parameters_mod
  implicit none

  allocate(vec_rhs(9*ndof_local,nE), vec_res(9*ndof_local,nE), vec_fel(9*ndof_local,nE))
  allocate(Mfl(9*ndof_local,9*ndof_local,4))
  allocate(Mfl_global(9*ndof_local,9*ndof_local,4,nE))
  
  allocate(Mds(9*ndof_local,9*ndof_local))
  allocate(Mds_global(9*ndof_local,9*ndof_local,nE))
  allocate(indx_to_use(2,4*ndof_local_face),indx_face_ref(4*ndof_local_face))
  allocate(flux(4*ndof_local_face))
  allocate(ve1(9*ndof_local))
  allocate(ve2(9*ndof_local))
  allocate(ve3(9*ndof_local))
  allocate(ve4(9*ndof_local))
  allocate(ve5(9*ndof_local))
  allocate(ve6(9*ndof_local))
end subroutine allocate_block_matrix_arrays

